//
//  ZoomSkeinXML.m
//  ZoomCocoa
//
//  Created by Andrew Hunter on Thu Jul 01 2004.
//  Copyright (c) 2004 Andrew Hunter. All rights reserved.
//

#import "ZoomSkein.h"
#import <ZoomView/ZoomView-Swift.h>

NSErrorDomain const ZoomSkeinXMLParserErrorDomain = @"uk.org.logicalshift.zoomview.skein.xmlerrors";

#pragma mark - XML input class

typedef NSString *ZoomSkeinXMLKey NS_TYPED_ENUM;

static ZoomSkeinXMLKey const ZoomSkeinXMLAttributes	= @"xmlAttributes";
static ZoomSkeinXMLKey const ZoomSkeinXMLName		= @"xmlName";
static ZoomSkeinXMLKey const ZoomSkeinXMLChildren	= @"xmlChildren";
static ZoomSkeinXMLKey const ZoomSkeinXMLType		= @"xmlType";
static ZoomSkeinXMLKey const ZoomSkeinXMLChars		= @"xmlChars";

static NSString* const xmlElement    = @"xmlElement";
static NSString* const xmlCharData   = @"xmlCharData";

typedef NSDictionary<ZoomSkeinXMLKey,id> SkeinXMLElement;
typedef NSDictionary<ZoomSkeinXMLKey,NSArray<SkeinXMLElement*>*> SkeinXMLDictionary;

@interface ZoomSkeinXMLInput : NSObject <NSXMLParserDelegate> {
	NSMutableDictionary* result;
	NSMutableArray<NSMutableDictionary*>*      xmlStack;
}

- (BOOL) processXML: (NSData*) xml error: (NSError**) outError;
- (BOOL) processXMLAtURL: (NSURL*) url error: (NSError**) outError;
- (void) processPreprocessedDictionary:(NSDictionary*)preDict;
- (NSDictionary*) processedXML;

- (SkeinXMLElement*) childForElement: (SkeinXMLDictionary*) element
							withName: (NSString*) elementName;
- (NSArray<SkeinXMLElement*>*) childrenForElement: (SkeinXMLDictionary*) element
										 withName: (NSString*) elementName;
- (NSString*) innerTextForElement: (SkeinXMLElement*) element;
- (NSString*) attributeValueForElement: (SkeinXMLElement*) element
							  withName: (NSString*) elementName;

@end

@implementation ZoomSkein(ZoomSkeinXML)

#pragma mark - Parsing the XML

- (BOOL) parseXmlData: (NSData*) data error: (NSError**) error {
	@autoreleasepool {
	
	ZoomSkeinXMLInput* inputParser = [[ZoomSkeinXMLInput alloc] init];
	
	// Process the XML associated with this file
	if (![inputParser processXML: data error: error]) {
		// Failed to parse
		NSLog(@"ZoomSkein: Failed to parse skein XML data");
		return NO;
	}
	
		return [self parseXMLInput: inputParser error: error];
	}
}

- (BOOL) parseXMLContentsAtURL: (NSURL*) url error: (NSError**) error {
	@autoreleasepool {
		ZoomSkeinXMLInput* inputParser = [[ZoomSkeinXMLInput alloc] init];
		
		// Process the XML associated with this file
		if (![inputParser processXMLAtURL: url error: error]) {
			// Failed to parse
			NSLog(@"ZoomSkein: Failed to parse skein XML data");
			return NO;
		}
		
		return [self parseXMLInput: inputParser error: error];
	}
}

- (BOOL) parseXMLInput:(ZoomSkeinXMLInput*)inputParser error:(NSError**)outError {
	// OK, actually process the data
	NSDictionary* skein = [inputParser childForElement: [inputParser processedXML]
											  withName: @"Skein"];
	
	if (skein == nil) {
		NSLog(@"ZoomSkein: Failed to find root 'Skein' element");
		if (outError) {
			*outError = [NSError errorWithDomain: ZoomSkeinXMLParserErrorDomain
											code: ZoomSkeinXMLErrorNoRootSkein
										userInfo: @{
				NSDebugDescriptionErrorKey: @"ZoomSkein: Failed to find root 'Skein' element",
				NSLocalizedDescriptionKey: @"ZoomSkein: Failed to find root 'Skein' element"
			}];
		}

		return NO;
	}
	
	// Header fields
	NSString* rootNodeId = [inputParser attributeValueForElement: skein
														withName: @"rootNode"];
	NSString* generator = [inputParser innerTextForElement: [inputParser childForElement: skein
																				withName: @"generator"]];
	NSString* activeNode = [inputParser attributeValueForElement: [inputParser childForElement: skein
																					  withName: @"activeNode"]
														withName: @"nodeId"];
	if (![generator isEqualToString: @"Zoom"]) {
		NSLog(@"ZoomSkein: XML file generated by %@", generator);
	}
	
	if (rootNodeId == nil) {
		NSLog(@"ZoomSkein: No root node ID specified");
		if (outError) {
			*outError = [NSError errorWithDomain: ZoomSkeinXMLParserErrorDomain
											code: ZoomSkeinXMLErrorNoRootNodeID
										userInfo: @{
				NSDebugDescriptionErrorKey: @"ZoomSkein: No root node ID specified",
				NSLocalizedDescriptionKey: @"ZoomSkein: No root node ID specified"
			}];
		}
		return NO;
	}
	
	if (activeNode == nil) {
		NSLog(@"ZoomSkein: Warning: No active node specified");
	}
	
	// Item dictionary: populate with items ready to be linked together
	NSMutableDictionary* itemDictionary = [NSMutableDictionary dictionary];
	
	NSArray* items = [inputParser childrenForElement: skein
											withName: @"item"];
	
	for (SkeinXMLElement* item in items) {
		NSString* itemNodeId = [inputParser attributeValueForElement: item
															withName: @"nodeId"];
		
		if (itemNodeId == nil) {
			NSLog(@"ZoomSkein: Warning - found item with no ID");
			continue;
		}
		
		ZoomSkeinItem* newItem = [[ZoomSkeinItem alloc] initWithCommand: @"- PLACEHOLDER -"];
		[itemDictionary setObject: newItem
						   forKey: itemNodeId];
	}
	
	// Item dictionary II: fill in the node data
	for (NSDictionary* item in items) {
		NSString* itemNodeId = [inputParser attributeValueForElement: item
															withName: @"nodeId"];
		
		if (itemNodeId == nil) {
			continue;
		}
		
		ZoomSkeinItem* newItem = [itemDictionary objectForKey: itemNodeId];
		if (newItem == nil) {
			// Should never happen
			// (Hahaha)
			NSString *spoon = [NSString stringWithFormat:@"ZoomSkein: Programmer is a spoon (item ID: %@)", itemNodeId];
			NSLog(@"%@", spoon);
			if (outError) {
				*outError = [NSError errorWithDomain: ZoomSkeinXMLParserErrorDomain
												code: ZoomSkeinXMLErrorProgrammerIsASpoon
											userInfo: @{
					NSDebugDescriptionErrorKey: spoon,
					NSLocalizedDescriptionKey: spoon
				}];
			}
			return NO;
		}
		
		// Item info
		NSString* command = [inputParser innerTextForElement: [inputParser childForElement: item
																				  withName: @"command"]];
		NSString* result = [inputParser innerTextForElement: [inputParser childForElement: item
																				 withName: @"result"]];
		NSString* annotation = [inputParser innerTextForElement: [inputParser childForElement: item
																					 withName: @"annotation"]];
		NSString* commentary = [inputParser innerTextForElement: [inputParser childForElement: item
																					 withName: @"commentary"]];
		BOOL played = [[inputParser innerTextForElement: [inputParser childForElement: item
																			 withName: @"played"]] isEqualToString: @"YES"];
		BOOL changed = [[inputParser innerTextForElement: [inputParser childForElement: item
																			  withName: @"changed"]] isEqualToString: @"YES"];
		BOOL temporary = [[inputParser innerTextForElement: [inputParser childForElement: item
																				withName: @"temporary"]] isEqualToString: @"YES"];
		int  tempVal = [[inputParser attributeValueForElement: [inputParser childForElement: item
																				   withName: @"temporary"]
													 withName: @"score"] intValue];
		
		if (command == nil) {
			NSLog(@"ZoomSkein: Warning: item with no command found");
			command = @"";
		}
		
		[newItem setCommand: command];
		[newItem setResult: result];
		[newItem setAnnotation: annotation];
		[newItem setCommentary: commentary];
		
		[newItem setPlayed: played];
		[newItem setChanged: changed];
		[newItem setTemporary: temporary];
		[newItem setTemporaryScore: tempVal];
	}
	
	// Item dictionary III: fill in the item children
	for (NSDictionary* item in items) {
		NSString* itemNodeId = [inputParser attributeValueForElement: item
															withName: @"nodeId"];
		
		if (itemNodeId == nil) {
			continue;
		}
		
		ZoomSkeinItem* newItem = [itemDictionary objectForKey: itemNodeId];
		if (newItem == nil) {
			// Should never happen
			// (Hahaha)
			NSString *spoon = [NSString stringWithFormat:@"ZoomSkein: Programmer is a spoon (item ID: %@)", itemNodeId];
			NSLog(@"%@", spoon);
			if (outError) {
				*outError = [NSError errorWithDomain: ZoomSkeinXMLParserErrorDomain
												code: ZoomSkeinXMLErrorProgrammerIsASpoon
											userInfo: @{
					NSDebugDescriptionErrorKey: spoon,
					NSLocalizedDescriptionKey: spoon
				}];
			}
			return NO;
		}

		// Item children
		NSArray* itemKids =[inputParser childrenForElement: [inputParser childForElement: item
																				withName: @"children"]
												  withName: @"child"];
		for (SkeinXMLElement* child in itemKids) {
			NSString* kidNodeId = [inputParser attributeValueForElement: child
															   withName: @"nodeId"];
			if (kidNodeId == nil) {
				NSLog(@"ZoomSkein: Warning: Child item with no node id");
				continue;
			}
			
			ZoomSkeinItem* kidItem = [itemDictionary objectForKey: kidNodeId];
			
			if (kidItem == nil) {
				NSLog(@"ZoomSkein: Warning: unable to find node %@", kidNodeId);
				continue;
			}
			
			ZoomSkeinItem* newKid = [newItem addChild: kidItem];
			[itemDictionary setObject: newKid
							   forKey: kidNodeId];
			kidItem = newKid;
		}
	}
	
	// Root item
	ZoomSkeinItem* newRoot = [itemDictionary objectForKey: rootNodeId];
	if (newRoot == nil) {
		if (outError) {
			*outError = [NSError errorWithDomain: ZoomSkeinXMLParserErrorDomain
											code: ZoomSkeinXMLErrorNoRootNode
										userInfo: @{
				NSDebugDescriptionErrorKey: @"ZoomSkein: No root node",
				NSLocalizedDescriptionKey: @"ZoomSkein: No root node"
			}];
		}
		NSLog(@"ZoomSkein: No root node");
		return NO;
	}
	
	rootItem = newRoot;
	
	if (activeNode != nil)
		self.activeItem = [itemDictionary objectForKey: activeNode];
	else
		self.activeItem = rootItem;
	
	[self zoomSkeinChanged];

	return YES;
}

@end

#pragma mark - XML input helper class

// For later, maybe: develop this into a class in it's own right?
// Would really want custom types for the XML tree, then

@implementation ZoomSkeinXMLInput

- (id) init {
	self = [super init];
	
	if (self) {
	}
	
	return self;
}

- (BOOL) processXML: (NSData*) xml error: (NSError**) outError {
	// Setup our state
	result = [[NSMutableDictionary alloc] init];
	xmlStack = [[NSMutableArray alloc] init];
	
	// Initial element on the stack
	[xmlStack addObject: result];
	
	// Initialise the expat parser
	NSXMLParser *theParser = [[NSXMLParser alloc] initWithData: xml];
	theParser.delegate = self;
	
	// Perform the parsing
	BOOL success = [theParser parse];
	if (!success && outError) {
		*outError = theParser.parserError;
	}
	return success;
}

- (BOOL) processXMLAtURL: (NSURL*) url error: (NSError**) outError {
	// Setup our state
	result = [[NSMutableDictionary alloc] init];
	xmlStack = [[NSMutableArray alloc] init];
	
	// Initial element on the stack
	[xmlStack addObject: result];
	
	// Initialise the expat parser
	NSXMLParser *theParser = [[NSXMLParser alloc] initWithContentsOfURL: url];
	if (!theParser) {
		if (outError) {
			*outError = [NSError errorWithDomain: NSCocoaErrorDomain
											code: NSFileReadUnknownError
										userInfo: @{NSURLErrorKey: url}];
		}
		return NO;
	}
	theParser.delegate = self;
	
	// Perform the parsing
	BOOL success = [theParser parse];
	if (!success && outError) {
		*outError = theParser.parserError;
	}
	return success;
}

- (NSDictionary*) processedXML {
	return result;
}

- (void) processPreprocessedDictionary:(NSDictionary*)preDict {
	result = [preDict mutableCopy];
}

// In the DOM, would iterate. Doesn't here (shouldn't matter)
- (NSString*) innerTextForElement: (SkeinXMLElement*) element {
	NSMutableString* res = nil;
	
	NSEnumerator* children = [[element objectForKey: ZoomSkeinXMLChildren] objectEnumerator];
	
	for (SkeinXMLElement* child in children) {
		if ([[child objectForKey: ZoomSkeinXMLType] isEqualToString: xmlCharData]) {
			if (res == nil) {
				res = [[NSMutableString alloc] initWithString: [child objectForKey: ZoomSkeinXMLChars]];
			} else {
				[res appendString: [child objectForKey: ZoomSkeinXMLChars]];
			}
		}
	}
	
	return res;
}

- (NSArray*) childrenForElement: (SkeinXMLElement*) element
					   withName: (NSString*) elementName {
	NSMutableArray* res = nil;
	
	NSEnumerator* children = [[element objectForKey: ZoomSkeinXMLChildren] objectEnumerator];
	
	for (SkeinXMLElement* child in children) {
		if ([[child objectForKey: ZoomSkeinXMLType] isEqualToString: xmlElement] &&
			[[child objectForKey: ZoomSkeinXMLName] isEqualToString: elementName]) {
			if (res == nil) {
				res = [[NSMutableArray alloc] init];
			}
			
			[res addObject: child];
		}
	}
	
	return res;
}

- (NSDictionary*) childForElement: (SkeinXMLDictionary*) element
						 withName: (NSString*) elementName {
	NSEnumerator* children = [[element objectForKey: ZoomSkeinXMLChildren] objectEnumerator];
	
	for (NSDictionary* child in children) {
		if ([[child objectForKey: ZoomSkeinXMLType] isEqualToString: xmlElement] &&
			[[child objectForKey: ZoomSkeinXMLName] isEqualToString: elementName]) {
			return child;
		}
	}
	
	return nil;
}

- (NSString*) attributeValueForElement: (NSDictionary*) element
							  withName: (NSString*) elementName {
	return [[element objectForKey: ZoomSkeinXMLAttributes] objectForKey: elementName];
}

#pragma mark - NSXML callback messages

-   (void)parser: (NSXMLParser *) parser
 didStartElement: (NSString *) elementName
	namespaceURI: (NSString *) namespaceURI
   qualifiedName: (NSString *) qName
	  attributes: (NSDictionary<NSString *,NSString *> *) attributeDict {
	// Create this element
	NSMutableDictionary* lastElement = [xmlStack lastObject];
	NSMutableDictionary* element = [NSMutableDictionary dictionary];

	[element setObject: xmlElement
				forKey: ZoomSkeinXMLType];
	[element setObject: elementName
				forKey: ZoomSkeinXMLName];
	
	// Attributes
	if ([attributeDict count] != 0) {
		[element setObject: [attributeDict mutableCopy]
					forKey: ZoomSkeinXMLAttributes];
	}
	
	// Add as a child of the previous element
	NSMutableArray* children = [lastElement objectForKey: ZoomSkeinXMLChildren];
	if (children == nil) {
		children = [NSMutableArray array];
		[lastElement setObject: children
						forKey: ZoomSkeinXMLChildren];
	}
	[children addObject: element];
	
	// Push this element
	[xmlStack addObject: element];
}

- (void) parser: (NSXMLParser *)parser
  didEndElement: (NSString *)elementName
   namespaceURI: (NSString *)namespaceURI
  qualifiedName: (NSString *)qName {
	// Pop the last element
	[xmlStack removeLastObject];
}

-   (void)parser: (NSXMLParser *)parser
 foundCharacters: (NSString *) string {
	if (string.length == 0) {
		return;
	}
	
	// Create this element
	NSMutableDictionary* lastElement = [xmlStack lastObject];
	NSMutableArray* children = [lastElement objectForKey: ZoomSkeinXMLChildren];
	NSMutableDictionary* element;
	BOOL addAsChild;
	
	if (children && [[[children lastObject] objectForKey: ZoomSkeinXMLType] isEqualToString: xmlCharData]) {
		element = [children lastObject];
		[[element objectForKey: ZoomSkeinXMLChars] appendString: string];
		
		addAsChild = NO;
	} else {
		element = [NSMutableDictionary dictionary];
		
		[element setObject: xmlCharData
					forKey: ZoomSkeinXMLType];
		[element setObject: [string mutableCopy]
					forKey: ZoomSkeinXMLChars];
		
		addAsChild = YES;
	}
	
	// Add as a child of the previous element, if required
	if (addAsChild) {
		if (children == nil) {
			children = [NSMutableArray array];
			[lastElement setObject: children
						forKey: ZoomSkeinXMLChildren];
		}
		[children addObject: element];
	}
}

@end
